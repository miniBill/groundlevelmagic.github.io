<!doctype html><html><head><title>HaskElm #2: don't put that on record | Ground Level Magic</title><meta charset="utf-8"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/highlight.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/languages/elm.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/languages/haskell.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/languages/bash.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/styles/default.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Open+Sans|Proza+Libre|Inconsolata" rel="stylesheet" type="text/css"></head><body><div class="header-logo"><img alt="miniBill's blog" src="/img/logo.png" width="100"></div><div class="navigation"><ul><li><a href="/posts">Posts</a></li><li><a href="/contact">Contact</a></li></ul></div><div class="sidebar"></div><div class="sidebar2"></div><div class="content"><h1>HaskElm #2: don't put that on record</h1><div class="post-metadata"><span>2019-08-01</span><span>•</span><a href="/tags/elm">elm</a><a href="/tags/haskell">haskell</a></div><div class="markdown"><h2 id="introduction">Introduction</h2>
<p>HaskElm is a project in which I try and rewrite a Prelude for Haskell that feels like Elm’s Prelude.</p>
<p>This set of posts is aimed at people with some experience in Elm (having read the guide should be enough) and no experience in Haskell.
It is structured as a log of my explorations, rather than a tutorial or an howto, so it will have warts, false ends and errors (although I’ll cut some of the uninteresting ones).</p>
<p>In <a href="/2019-07-31-haskelm-1-getting-the-caball-rolling">part I</a> we tried to work with records in Haskell.</p>
<p>It was painful but we were finally able to compile something using <code>HList</code> and some fairly recent GHC extensions.</p>
<p>In the end I don’t think the pain is worth the result (right now), so we’ll drop records and Keep It Simple.</p>
<p>Everything is formatted with <code>hfmt</code>, which is an opinionated formatted, à la <code>gofmt</code> or <code>elm-format</code>, so you may not like its style (I don’t love it), but it eliminates bikeshedding and lost time on formatting decisions, so I like it for that.</p>
<p><code>src/Prelude.hs</code></p>
<pre><code class="lang-haskell">{-# LANGUAGE PackageImports #-} -- This is needed so we can import the "official" Prelude

module Prelude
  ( IO
  , String
  , (&lt;|)
  ) where

import qualified "base" Prelude as P

type IO a = P.IO a -- We have to expose it, because `main` must have type `IO ()`

type String = P.String -- Strings in Haskell are actually List Char, but for now we don't care.

infixr 0 &lt;|

(&lt;|) :: (a -&gt; b) -&gt; a -&gt; b
f &lt;| x = f x
</code></pre>
<p>This is the absolute minimum we’ll need for out first example.</p>
<p><code>src/CLI.hs</code></p>
<pre><code class="lang-haskell">{-# LANGUAGE PackageImports #-}

module CLI
  ( CLI
  , Program
  , run
  , run_
  , sandbox
  , text
  ) where

import qualified "base" Prelude

data CLI msg =
  Text String -- We only have a single kind of view for now: a text string

data Program flags model msg =
  Program
    (flags -&gt; model) -- init
    (model -&gt; CLI msg) -- view
    (msg -&gt; model -&gt; (model, IO [msg])) -- update

run_ :: Program () model msg -&gt; IO ()
run_ = run ()

run :: flags -&gt; Program flags model msg -&gt; IO ()
run flags (Program init view update) =
  let model = init flags
      unpack w =
        case w of
          Text s -&gt; s
   -- let's keep it ultra-simple for now, and just echo the initial view to screen
   in do Prelude.putStrLn &lt;| unpack &lt;| view model

sandbox ::
     model
  -&gt; (model -&gt; CLI msg)
  -&gt; (msg -&gt; model -&gt; model)
  -&gt; Program () model msg
sandbox init view update =
  let init' _ = init
      update' msg model = (update msg model, Prelude.return [])
   in Program init' view update'

text :: String -&gt; CLI msg
text = Text
</code></pre>
<p>We just want to put something on the screen, we will be adding actual message handling later.</p>
<p><code>app/Main.hs</code></p>
<pre><code class="lang-haskell">module Main
  ( main
  ) where

import           CLI

type Flags = ()

type Model = ()

type Msg = ()

main :: IO ()
main =
  let init = ()
      view _ = CLI.text "Hello world!"
      update _ model = model
   in CLI.run_ &lt;| CLI.sandbox init view update
</code></pre>
<p>This is not as clean as a record would be in Elm, but still pretty readable IMO.</p>
<p><code>haskelm.cabal</code>:</p>
<pre><code class="lang-cabal">name:                haskelm
version:             0.1.0.0
-- synopsis:
-- description:
license:             BSD3
license-file:        LICENSE
author:              Leonardo Taglialegne
maintainer:          cmt.miniBill@gmail.com
-- copyright:
-- category:
build-type:          Simple
extra-source-files:  ChangeLog.md
cabal-version:       &gt;=1.10

library
  exposed-modules:   Prelude, CLI
  build-depends:     base &gt;=4.11 &amp;&amp; &lt;4.12
  hs-source-dirs:    src
  default-language:  Haskell2010
  ghc-options:       -Wall -Werror

executable haskelm
  main-is:           Main.hs
  build-depends:     haskelm
  hs-source-dirs:    app
  default-language:  Haskell2010
</code></pre>
<p>This is much simpler than what we reached in Part I.</p>
<pre><code class="lang-bash">$ cabal run
Preprocessing library for haskelm-0.1.0.0..
Building library for haskelm-0.1.0.0..
[1 of 2] Compiling Prelude          ( src/Prelude.hs, dist/build/Prelude.o )
[2 of 2] Compiling CLI              ( src/CLI.hs, dist/build/CLI.o )
Preprocessing executable 'haskelm' for haskelm-0.1.0.0..
Building executable 'haskelm' for haskelm-0.1.0.0..
[1 of 1] Compiling Main             ( app/Main.hs, dist/build/haskelm/haskelm-tmp/Main.o )
Linking dist/build/haskelm/haskelm ...
Running haskelm...
Hello world!
</code></pre>
<p>Yay! Simple wins again!</p>
<h2 id="a-simple-loop">A simple loop</h2>
<p>Let’s swap the implementation of <code>run</code> in <code>CLI.hs</code> with:</p>
<pre><code class="lang-haskell">import qualified "base" Control.Monad      as Monad -- Monads!!!

run :: flags -&gt; Program flags model msg -&gt; IO ()
run flags (Program init view _) =
  let model = init flags
      unpack w =
        case w of
          Text s -&gt; s
   in do Prelude.putStrLn &lt;| unpack &lt;| view model
         Monad.forever &lt;| return ()
</code></pre>
<p>Ok, let’s talk about the M word. I <em>will</em> be using monads but I’ll try to keep it simple, and use them only in the implementation, what in Elm would be kernel code.</p>
<p>Monads are simply types <code>M x</code> with two functions:</p>
<ul>
<li><code>return :: x -&gt; M x</code>, this is usually trivial, <code>\x -&gt; [x]</code> for <code>List</code>, <code>\x -&gt; Just x</code> for <code>Maybe</code>, <code>\x -&gt; Ok x</code> for <code>Result</code>,… It takes a value and puts it inside the type;</li>
<li><code>(&gt;&gt;=) :: M x -&gt; (x -&gt; M y) -&gt; M y</code> this is Elm’s <code>andThen</code> with arguments flipped (<code>List.andThen</code>, <code>Maybe.andThen</code>, <code>Result.andThen</code>, <code>Decoder.andThen</code>, …).</li>
</ul>
<p><code>do</code> is just a compact notation, without it we would have to write:</p>
<pre><code class="lang-haskell">(Prelude.putStrLn &lt;| unpack &lt;| view model) &gt;&gt;= {- |&gt; andThen -} (\_ -&gt;
  Monad.forever &lt;| return ())
</code></pre>
<p><code>Monad.forever</code> just does what it says on the tin: it executes something forever.</p>
<p>This works but consumes a lot of CPU while idling. The simplest way to not do that is to suspend the thread a bit:</p>
<pre><code class="lang-haskell">import qualified "base" Control.Concurrent as Concurrent

run :: flags -&gt; Program flags model msg -&gt; IO ()
run flags (Program init view _) =
  let model = init flags
   in do Prelude.print &lt;| view model
         Monad.forever &lt;| Concurrent.threadDelay 100
</code></pre>
<p>Much better, the CPU usage stays under 1%.</p>
<h2 id="count-von-count">Count von Count</h2>
<p>Ok, let’s try to implement the simplest example: the simple counter.</p>
<pre><code class="lang-elm">import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

main =
  Browser.sandbox { init = 0, update = update, view = view }

type Msg = Increment | Decrement

update msg model =
  case msg of
    Increment -&gt;
      model + 1

    Decrement -&gt;
      model - 1

view model =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (String.fromInt model) ]
    , button [ onClick Increment ] [ text "+" ]
    ]
</code></pre>
<p>This becomes:</p>
<p><code>app/Main.hs</code>:</p>
<pre><code class="lang-haskell">module Main
  ( main
  ) where

import           CLI            (button, row, text)
import qualified CLI
import           CLI.Attributes (onClick)

-- unfortunately Haskell does not support qualified module exports, so we have to explicitly import modules instead of just exposing them from Prelude
import qualified String

main :: IO ()
main = CLI.run_ &lt;| CLI.sandbox 0 view update

data Msg
  = Increment
  | Decrement

update msg model =
  case msg of
    Increment -&gt; model + 1
    Decrement -&gt; model - 1

view model =
  row
    [ button [onClick Decrement] [text "-"]
    , text &lt;| String.fromInt model
    , button [onClick Increment] [text "+"]
    ]
</code></pre>
<p>Ok, let’s try and implement this API!</p>
<p>In <code>src/CLI/Attributes.hs</code> (a new file):</p>
<pre><code class="lang-haskell">module CLI.Attributes
  ( Attribute
  , onClick
  ) where

data Attribute msg =
  OnClick msg

onClick :: msg -&gt; Attribute msg
onClick = OnClick
</code></pre>
<p>Add <code>CLI.Attributes</code> to the <code>other-modules</code> in the cabal file.</p>
<p>In <code>CLI.elm</code> we overwrite/add the following:</p>
<pre><code class="lang-haskell">import           CLI.Attributes            (Attribute)

data CLI msg
  = Text String
  | Row (List (CLI msg))
  | Button (List (Attribute msg)) (List (CLI msg))

run :: flags -&gt; Program flags model msg -&gt; IO ()
run flags (Program init view _) =
  let model = init flags
      unpack w =
        case w of
          Text s            -&gt; s
          Row xs            -&gt; String.intersperse " " &lt;| List.map unpack xs
          Button _ children -&gt; "[ " ++ unpack (Row children) ++ " ]"
   in do Prelude.putStrLn &lt;| unpack &lt;| view model
         Monad.forever &lt;| Concurrent.threadDelay 100

button :: List (Attribute msg) -&gt; List (CLI msg) -&gt; CLI msg
button = Button

row :: List (CLI msg) -&gt; CLI msg
row = Row
</code></pre>
<p>We should split <code>Prelude.hs</code>: we’ll keep a <code>Prelude</code> (exposed to <code>CLI</code>, applications), and a <code>Protolude</code> (used to build the <code>Prelude</code> itself).</p>
<p><code>src/Prelude.hs</code></p>
<pre><code class="lang-haskell">module Prelude
  ( Appendable(..)
  , Int
  , IO
  , List
  , Maybe(..)
  , Number(..)
  , String
  , (&lt;|)
  ) where

import           Protolude
</code></pre>
<p><code>src/Protolude.hs</code></p>
<pre><code class="lang-haskell">{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE PackageImports    #-}

module Protolude
  ( Appendable(..)
  , Int
  , IO
  , List
  , Maybe(..)
  , Number(..)
  , String
  , (&lt;|)
  ) where

import           "base" Prelude (IO, Maybe, String)
import qualified "base" Prelude as P

type Int = P.Integer

type List a = [a]

infixr 0 &lt;|

(&lt;|) :: (a -&gt; b) -&gt; a -&gt; b
f &lt;| x = f x

class Appendable a where
  (++) :: a -&gt; a -&gt; a

instance Appendable [a] where
  (++) = (P.++)

class Number a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a

instance Number P.Integer where
  (+) = (P.+)
  (-) = (P.-)
</code></pre>
<p>We need <code>class</code> and <code>instance</code> to define the equivalent of Elm’s “magic” <code>number</code> and <code>appendable</code>. In Haskell we use typeclasses.
Typeclasses are sets of generic functions, and instances are how those functions are defined for types. Again, we’ll use this in “kernel” code, but clients need not worry.</p>
<p>Add <code>Protolude</code> to the <code>other-modules</code> in the cabal file.</p>
<p>In <code>src/String.hs</code> (a new file):</p>
<pre><code class="lang-haskell">{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE PackageImports    #-}

module String
  ( fromInt
  , intersperse
  ) where

import qualified List
import qualified "base" Prelude as P
import           Protolude

fromInt :: Int -&gt; String
fromInt = P.show

intersperse :: String -&gt; List String -&gt; String
intersperse _ []     = ""
intersperse s (x:xs) = List.foldl (\e a -&gt; e ++ s ++ a) x xs
</code></pre>
<p>Add <code>String</code> to the <code>exposed-modules</code> in the cabal file.</p>
<p>In <code>src/List.hs</code> (a new file):</p>
<pre><code class="lang-haskell">{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE PackageImports    #-}

module List
  ( foldl
  , map
  ) where

import qualified "base" Prelude as P
import           Protolude

map :: (a -&gt; b) -&gt; List a -&gt; List b
map = P.map

foldl :: (e -&gt; a -&gt; a) -&gt; a -&gt; List e -&gt; a
foldl f = P.foldl &lt;| \a e -&gt; f e a
</code></pre>
<p>Add <code>List</code> to the <code>exposed-modules</code> in the cabal file.</p>
<pre><code class="lang-bash">$ cabal run
Preprocessing library for haskelm-0.1.0.0..
Building library for haskelm-0.1.0.0..
[1 of 6] Compiling Protolude        ( src/Protolude.hs, dist/build/Protolude.o )
[2 of 6] Compiling Prelude          ( src/Prelude.hs, dist/build/Prelude.o )
[4 of 6] Compiling List             ( src/List.hs, dist/build/List.o )
[5 of 6] Compiling String           ( src/String.hs, dist/build/String.o )
[6 of 6] Compiling CLI              ( src/CLI.hs, dist/build/CLI.o )
Preprocessing executable 'haskelm' for haskelm-0.1.0.0..
Building executable 'haskelm' for haskelm-0.1.0.0..
[1 of 1] Compiling Main             ( app/Main.hs, dist/build/haskelm/haskelm-tmp/Main.o )
Linking dist/build/haskelm/haskelm ...
Running haskelm...
[ + ] 0 [ - ]
</code></pre>
<p>It works!</p>
<h2 id="in-the-next-episode">In the next episode</h2>
<p>We’ll start implementing user interactions!</p>
<p>Continue to <a href="/2019-08-03-haskelm-3-egyptian-ncurses">Part III</a>!</p>
</div></div><div class="footer"><img alt="miniBill's blog" src="/img/logo.png" style="float: left; padding-top: 7px" width="75"><div class="link"><svg width="16" height="16" viewbox="0 0 16 16"><path fill="#fff" d="
M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z
            "></path></svg><a href="https://github.com/miniBill">miniBill's GitHub</a></div><div class="link"><svg width="16" height="16" viewbox="0 0 16 16"><path fill="#fff" d="
M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809 c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z
            "></path></svg><a href="https://twitter.com/minibill">miniBill's Twitter</a></div><div class="link"><a href="https://www.npmjs.com/package/elmstatic">Created with Elmstatic</a></div></div><link href="/styles.css" rel="stylesheet" type="text/css"><style>body {
    padding:0px;
    margin:0px;
    background-color:#ffffff;
    color:#363636;
    font-family:Open Sans, Arial, sans-serif;
    font-size:18px;
    line-height:1.4em;
}

a {
    color:#348aa7;
    text-decoration:none;
}

code {
    font-family:Inconsolata, monospace;
}

pre  code {
    overflow-x:scroll !important;
}

h1, h2, h3, h4, h5, h6 {
    font-family:Proza Libre, Helvetica, sans-serif;
    line-height:1.1em;
}

h1 {
    font-size:2.66667em;
    margin-bottom:2.0202rem;
}

h2 {
    font-size:2em;
    margin-bottom:1.61616rem;
}

h3 {
    font-size:1.33333em;
    margin-bottom:1.21212rem;
}

h4 {
    font-size:1.2em;
    margin-bottom:0.80808rem;
}

h5, h6 {
    font-size:1em;
    margin-bottom:0.60606rem;
}

p {
    margin:auto auto 1.5rem;
}

small {
    font-size:65%;
}

.header-logo {
    padding-top:6px;
    text-align:center;
    background-color:#f2fae8;
}

@media only screen and (min-width: 600px) {
    .header-logo {
        text-align:left;
    border-bottom:2px solid #3c8765;
    }
}

.navigation {
    text-align:center;
    border-bottom:2px solid #3c8765;
    background-color:#f2fae8;
    padding:10px;
    margin-top:-20px;
}

@media only screen and (min-width: 600px) {
    .navigation {
        margin-top:0px;
    padding:0px;
    text-align:right;
    }
}

.navigation  ul {
    margin:0px;
    padding:0px;
}

@media only screen and (min-width: 600px) {
    .navigation  ul {
        line-height:100px;
    }
}

.navigation  li {
    display:inline-block;
    margin-right:20px;
}

.content {
    max-width:100vw;
}

.footer {
    text-align:center;
    border-top:2px solid #2f4858;
    background-color:#348aa7;
    color:#ffffff;
}

@media only screen and (min-width: 600px) {
    .footer {
        line-height:80px;
    text-align:right;
    }
}

@media only screen and (min-width: 600px) {
    .footer  .link {
        display:inline-block;
    margin-right:20px;
    }
}

.footer  a {
    color:#ffffff;
    text-decoration:none;
}

.footer  svg {
    padding-right:5px;
    vertical-align:baseline;
}

.post-metadata {
    margin-top:-0.5em;
    margin-bottom:2em;
}

.post-metadata  a, .post-metadata  span {
    display:inline-block;
    margin-right:5px;
}

.post-metadata  a {
    border:1px solid #e0e0e0;
    border-radius:3px;
    background-color:#f2fae8;
    padding-left:5px;
    padding-right:5px;
}</style></body></html>