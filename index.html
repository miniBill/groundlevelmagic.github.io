<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Ground Level Magic</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <header>
        <h1>Ground Level Magic</h1>
        <em>doing magic while keeping it simple</em>
    </header>
    <!--<nav>
        <b>Home</b>
        -
        <a href="/about">About</a>
    </nav>
    -->
    <article>
        <h2>HaskElm #1: getting the (ca)ball rolling</h2>
        <p>
            HaskElm is a project in which I try and rewrite a Prelude for Haskell that feels like Elm's Prelude.
        </p>
        <p>
            Let's start with a minimal viable example: the target will be to compile the following program:
        </p>
        <p>
            <code>
                <pre>
module Main(main) where

import CLI

type Flags = ()

type Model = ()

type Msg = ()

main :: IO ()
main =
    CLI.sandbox
        { init = \flags -> ()
        , view = \model -> CLI.text "Hello world!"
        , update = \msg model -> model
        }
</pre>
            </code>
            Seems simple, right? We'll see...
        </p>
        <h3>Cabal init</h3>
        <p>
            Let's keep it simple: we'll start with <code>cabal</code>,
            then switch to <code>stack</code> later.
        </p>
        <p>
            <code>
                $ sudo apt install cabal-install<br />
                $ mkdir haskelm<br />
                $ cd haskelm<br />
                $ cabal init<br />
                ... Answer some questions, mostly with defaults ...<br />
            </code>
        </p>
        <p>
            The only significant choice is building a library and an executable
            (we'll write the Prelude inside the library, the minimal code from above
            in the executable).
        </p>
        <p>
            Let's go ahead and edit the generated <code>haskelm.cabal</code> file,
            by removing the <code>build-depends: base &gt;= x.yy && &lt; x.zz</code> part,
            and setting the hs-source-dirs for the executable to <code>app</code>.
            Then we can then create <code>app/Main.hs</code> with the code from above.
        </p>
        <h3>Trying to build</h3>
        <p>
            Let's try and do it Elm-style: we'll follow the compiler errors and try
            to make things work from here!
        </p>
        <p>
            <code>cabal build</code>
        </p>
        <p>
            First error is GHC warning us that the <code>Main</code> module for the
            executable cannot find the <code>Prelude</code> and <code>CLI</code> modules,
            so let's stub them.
        </p>
        <p>
            We'll only need <code>IO</code> in <code>Prelude</code>,
            <code>sandbox</code> and <code>text</code> in <code>CLI</code>,
            so let's do that.
        </p>
        <p>
            <code>src/Prelude.hs
                <pre>
module Prelude(IO) where

import qualified "base" Prelude as P -- Import the standard Prelude

type IO a = P.IO a
                </pre>
            </code>
        </p>
        <p>
            <code>src/CLI.hs
                <pre>
module CLI(CLI, sandbox, text) where

data CLI msg = Todo

sandbox :: { init :: flags -> model, update :: msg -> model -> model, view :: model -> CLI msg } -> IO ()
sandbox = error "Todo"

text :: String -> CLI msg
text msg = error "Todo"
                </pre>
            </code>
        </p>
        <p>
            We create those two files, try to <code>cabal build</code>
            again and... nothing changes. We change <code>haskelm.cabal</code> to add
            <code>Prelude</code> and <code>CLI</code> to the library's
            <code>exposed-modules</code> and try again... with the same
            result. A little Google later (thanks Stack Overflow!), we add
            <code>build-depends: haskelm</code> to the executable section in
            <code>haskelm.cabal</code> and the error finally changes!
        </p>
        <p>
            <code>Package-qualified imports are not enabled; use PackageImports</code>
        </p>
        <p>
            Oh well... <code>default-extensions: PackageImports</code> in the library
            section of <code>haskelm.cabal</code> and off we go!
        </p>
        <p>
            Let's see what does GHC have to say about our code:
            <ol>
                <li>We cannot write a record in the type signature.</li>
                <li>
                    We are missing a <code>String</code> definition
                    in our <code>Prelude</code>.
                </li>
            </ol>
        </p>
        <p>
            The <code>String</code> error is trivial to fix:
            <code>type String = P.String</code> (and the corresponding <code>String</code>
            in the exposing section of <code>Prelude</code>).
        </p>
        <h3>Modern Records</h3>
        <p>
            A search on the record syntax brings us to
            <a href="https://wiki.haskell.org/Extensible_record">this page</a>
            in Haskell's wiki, which talks about some unfinished tickets and links
            to some existing libraries. Let's have a look at the libraries!
        </p>
        <h4>vinyl</h4>
        <p>
            Url:
            <a href="https://hackage.haskell.org/package/vinyl">
                https://hackage.haskell.org/package/vinyl
            </a>.<br />
            The hackage page is really bare. Let's try and find some docs:
            there is a <a href="https://github.com/VinylRecords/Vinyl/">README</a> that points to
            a <a href="https://github.com/VinylRecords/Vinyl/blob/master/tests/Intro.lhs">tutorial</a>.
            Nope, way too complex; remember, our main objective is to keep everything simple!
        </p>
        <h4>grapefruit-records</h4>
        <p>
            I can't seem to find an example.
        </p>
        <h4>named-records</h4>
        <p>
            Url:
            <a href="https://hackage.haskell.org/package/named-records">
                https://hackage.haskell.org/package/named-records
            </a>.<br />
            The hackage page looks encouraging (there is a mention of extending records).
            The link to the source repo is broken. Actual link is
            <a href="https://hub.darcs.net/scravy/named-records">
                https://hub.darcs.net/scravy/named-records
            </a> (probably).
            The <a href="https://hub.darcs.net/scravy/named-records/browse/examples/Sample.hs">example</a>
            doesn't look bad, although it uses Template Haskell it's reasonably readable.
        </p>
        <h4>has</h4>
        <p>
            Url:
            <a href="https://hackage.haskell.org/package/has">
                https://hackage.haskell.org/package/has
            </a>.<br />
            <b>It has a link to an example in the hackage page!</b> Cautiosly optimistic!
            Ouch, a field can only has a single type per module...
            <em>Might</em> work but I'm much less enthusiast.
        </p>
    </article>
    <footer>
        <p>
            This work is licensed under a
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
                Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License
            </a>.
            <br />
            The included source is released under the terms of the
            <a href="https://opensource.org/licenses/BSD-3-Clause">3-Clause BSD License</a>.
        </p>
    </footer>
</body>

</html>